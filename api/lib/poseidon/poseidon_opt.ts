// Parameters are generated by a reference script https://extgit.iaik.tugraz.at/krypto/hadeshash/-/blob/master/code/generate_parameters_grain.sage
// Used like so: sage generate_parameters_grain.sage 1 0 254 2 8 56 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001

// Using recommended parameters from whitepaper https://eprint.iacr.org/2019/458.pdf (table 2, table 8)
// Generated by https://extgit.iaik.tugraz.at/krypto/hadeshash/-/blob/master/code/calc_round_numbers.py
// And rounded up to nearest integer that divides by t

// Optimization is taken from https://github.com/filecoin-project/neptune

import assert from "assert";
// import { getCurveFromName }  from "@krigga/ffjavascript";
const {getCurveFromName} = require("@krigga/ffjavascript")

import poseidonConstants from "./poseidon_constants_opt";
import { ethers } from "ethers";

function unsringifyConstants(Fr: any, o: any): any {
    if ((typeof(o) == "string") && (/^[0-9]+$/.test(o) ))  {
        return Fr.e(o);
    } else if ((typeof(o) == "string") && (/^0x[0-9a-fA-F]+$/.test(o) ))  {
        return Fr.e(o);
    } else if (Array.isArray(o)) {
        return o.map(unsringifyConstants.bind(null, Fr));
    } else if (typeof o == "object") {
        if (o===null) return null;
        const res: any = {};
        const keys = Object.keys(o);
        keys.forEach( (k) => {
            res[k] = unsringifyConstants(Fr, o[k]);
        });
        return res;
    } else {
        return o;
    }
}



export default async function buildPoseidon() {
    const bn128 = await getCurveFromName("bn128", true);

    const F = bn128.Fr;

    const opt = unsringifyConstants(F, poseidonConstants);

    const N_ROUNDS_F = 8;
    const ROUNDS_P = [56, 57, 56, 60, 60, 63, 64, 63,] // 60, 66, 60, 65, 70, 60, 64, 68];

    const pow5 = (a: any) => F.mul(a, F.square(F.square(a, a)));

    function poseidon(inputs: Array<string>, initState: any, nOut: any) {
        assert(inputs !== null)
        assert(inputs.map !== null)
        assert(inputs.length > 0);
        assert(inputs.length <= ROUNDS_P.length);

        function arrToNumStr(fArr: Uint8Array[]): string[]{
            let ret: string[] = []
            fArr.forEach( e => {
                ret.push(F.toString(e))
            })
            return ret
        }

        // if (initState) {
        //     initState = F.e(initState);
        // } else {
        //     initState = F.zero;
        // }
        nOut = nOut || 1;


        const t = inputs.length + 1;
        const nRoundsF = N_ROUNDS_F;

        const nRoundsP = ROUNDS_P[t - 2];
        const C = opt.C[t-2];
        // const S = opt.S[t-2];
        const M = opt.M[t-2];
        // const P = opt.P[t-2];
        if(inputs === null || inputs.length === 0) return null
        let insfd: any[] = inputs.map((a: string) => F.e(a))
        // let state = [initState, ...insfd];
        let state = [F.zero, ...insfd];

        // console.log("Printing inside poseidon_opt.ts")

        // console.log(`initial state: ${arrToNumStr(state)}`)

        // const f = 8;
        const p = nRoundsP
        for(let r=0; r<N_ROUNDS_F+p; r++){
        // for(let r=0; r<2; r++){
            // console.log(`outer loop r: ${r}`)
            //ark
            for(let i=0; i<t; i++){ 
                state[i] = F.add(state[i], C[r*t + i])
            }
            // console.log(`state after ark ${arrToNumStr(state)}`)

            //sbox
            state[0] = pow5(state[0])
            for(let i=1; i<t; i++){
                state[i] = ((r < N_ROUNDS_F/2) || r >= (N_ROUNDS_F/2 + p)) ? pow5(state[i]): state[i]
            }
            // console.log(`state after sbox ${arrToNumStr(state)}`)

            //mix
            let out = []
            for(let i=0; i<t; i++){
                let acc = F.zero
                for(let j=0; j<t; j++){
                    acc = F.add(acc, F.mul(M[i][j],state[j]))
                }
                out.push(acc)
            }
            state = out
            // console.log(`state after mix ${arrToNumStr(state)}`)
        }
        
        // state = state.map((a, i) => F.add(a, C[i]));
        
        // //ark

        // //sbox
        // for (let r = 0; r < nRoundsP; r++) {
        //     state[0] = pow5(state[0]);
        //     state[0] = F.add(state[0], C[(nRoundsF/2 +1)*t + r]);


        //     const s0 = state.reduce((acc, a, j) => {
        //         return F.add(acc, F.mul(S[(t*2-1)*r+j], a));
        //     }, F.zero);
        //     for (let k=1; k<t; k++) {
        //         state[k] = F.add(state[k], F.mul(state[0], S[(t*2-1)*r+t+k-1]   ));
        //     }
        //     state[0] =s0;
        // }


        // for (let r = 0; r < nRoundsF/2-1; r++) {
        //     state = state.map(a => pow5(a));
        //     state = state.map((a, i) => F.add(a, C[(r +1)* t +i]));
        //     state = state.map((_, i) =>
        //         state.reduce((acc, a, j) => F.add(acc, F.mul(M[j][i], a)), F.zero)
        //     );
        // }
        // state = state.map(a => pow5(a));
        // state = state.map((a, i) => F.add(a, C[(nRoundsF/2-1 +1)* t +i]));
        // state = state.map((_, i) =>
        //     state.reduce((acc, a, j) => F.add(acc, F.mul(P[j][i], a)), F.zero)
        // );


        // for (let r = 0; r < nRoundsF/2-1; r++) {
        //     state = state.map(a => pow5(a));
        //     state = state.map((a, i) => F.add(a, C[ (nRoundsF/2 +1)*t + nRoundsP + r*t + i ]));
        //     state = state.map((_, i) =>
        //         state.reduce((acc, a, j) => F.add(acc, F.mul(M[j][i], a)), F.zero)
        //     );
        // }
        // state = state.map(a => pow5(a));
        // state = state.map((_, i) =>
        //     state.reduce((acc, a, j) => F.add(acc, F.mul(M[j][i], a)), F.zero)
        // );

        // if (nOut == 1) {
        //     return state[0]
        // } else {
        //     return state.slice(0, nOut);
        // }
        // console.log(state)
        return F.toString(state[0])
    }

    poseidon.F = F;
    return poseidon;
}


