"use strict";
// Parameters are generated by a reference script https://extgit.iaik.tugraz.at/krypto/hadeshash/-/blob/master/code/generate_parameters_grain.sage
// Used like so: sage generate_parameters_grain.sage 1 0 254 2 8 56 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
// Using recommended parameters from whitepaper https://eprint.iacr.org/2019/458.pdf (table 2, table 8)
// Generated by https://extgit.iaik.tugraz.at/krypto/hadeshash/-/blob/master/code/calc_round_numbers.py
// And rounded up to nearest integer that divides by t
// Optimization is taken from https://github.com/filecoin-project/neptune
var assert_1 = require("assert");
// import { getCurveFromName }  from "@krigga/ffjavascript";
var getCurveFromName = require("@krigga/ffjavascript").getCurveFromName;
var poseidon_constants_opt_1 = require("./poseidon_constants_opt");
function unsringifyConstants(Fr, o) {
    if ((typeof (o) == "string") && (/^[0-9]+$/.test(o))) {
        return Fr.e(o);
    }
    else if ((typeof (o) == "string") && (/^0x[0-9a-fA-F]+$/.test(o))) {
        return Fr.e(o);
    }
    else if (Array.isArray(o)) {
        return o.map(unsringifyConstants.bind(null, Fr));
    }
    else if (typeof o == "object") {
        if (o === null)
            return null;
        var res_1 = {};
        var keys = Object.keys(o);
        keys.forEach(function (k) {
            res_1[k] = unsringifyConstants(Fr, o[k]);
        });
        return res_1;
    }
    else {
        return o;
    }
}
function buildPoseidon() {
    return __awaiter(this, void 0, void 0, function () {
        function poseidon(inputs, initState, nOut) {
            (0, assert_1.default)(inputs !== null);
            (0, assert_1.default)(inputs.map !== null);
            (0, assert_1.default)(inputs.length > 0);
            (0, assert_1.default)(inputs.length <= ROUNDS_P.length);
            function arrToNumStr(fArr) {
                var ret = [];
                fArr.forEach(function (e) {
                    ret.push(F.toString(e));
                });
                return ret;
            }
            // if (initState) {
            //     initState = F.e(initState);
            // } else {
            //     initState = F.zero;
            // }
            nOut = nOut || 1;
            var t = inputs.length + 1;
            var nRoundsF = N_ROUNDS_F;
            var nRoundsP = ROUNDS_P[t - 2];
            var C = opt.C[t - 2];
            // const S = opt.S[t-2];
            var M = opt.M[t - 2];
            // const P = opt.P[t-2];
            if (inputs === null || inputs.length === 0)
                return null;
            var insfd = inputs.map(function (a) { return F.e(a); });
            // let state = [initState, ...insfd];
            var state = __spreadArray([F.zero], insfd, true);
            // console.log("Printing inside poseidon_opt.ts")
            // console.log(`initial state: ${arrToNumStr(state)}`)
            // const f = 8;
            var p = nRoundsP;
            for (var r = 0; r < N_ROUNDS_F + p; r++) {
                // for(let r=0; r<2; r++){
                // console.log(`outer loop r: ${r}`)
                //ark
                for (var i = 0; i < t; i++) {
                    state[i] = F.add(state[i], C[r * t + i]);
                }
                // console.log(`state after ark ${arrToNumStr(state)}`)
                //sbox
                state[0] = pow5(state[0]);
                for (var i = 1; i < t; i++) {
                    state[i] = ((r < N_ROUNDS_F / 2) || r >= (N_ROUNDS_F / 2 + p)) ? pow5(state[i]) : state[i];
                }
                // console.log(`state after sbox ${arrToNumStr(state)}`)
                //mix
                var out = [];
                for (var i = 0; i < t; i++) {
                    var acc = F.zero;
                    for (var j = 0; j < t; j++) {
                        acc = F.add(acc, F.mul(M[i][j], state[j]));
                    }
                    out.push(acc);
                }
                state = out;
                // console.log(`state after mix ${arrToNumStr(state)}`)
            }
            // state = state.map((a, i) => F.add(a, C[i]));
            // //ark
            // //sbox
            // for (let r = 0; r < nRoundsP; r++) {
            //     state[0] = pow5(state[0]);
            //     state[0] = F.add(state[0], C[(nRoundsF/2 +1)*t + r]);
            //     const s0 = state.reduce((acc, a, j) => {
            //         return F.add(acc, F.mul(S[(t*2-1)*r+j], a));
            //     }, F.zero);
            //     for (let k=1; k<t; k++) {
            //         state[k] = F.add(state[k], F.mul(state[0], S[(t*2-1)*r+t+k-1]   ));
            //     }
            //     state[0] =s0;
            // }
            // for (let r = 0; r < nRoundsF/2-1; r++) {
            //     state = state.map(a => pow5(a));
            //     state = state.map((a, i) => F.add(a, C[(r +1)* t +i]));
            //     state = state.map((_, i) =>
            //         state.reduce((acc, a, j) => F.add(acc, F.mul(M[j][i], a)), F.zero)
            //     );
            // }
            // state = state.map(a => pow5(a));
            // state = state.map((a, i) => F.add(a, C[(nRoundsF/2-1 +1)* t +i]));
            // state = state.map((_, i) =>
            //     state.reduce((acc, a, j) => F.add(acc, F.mul(P[j][i], a)), F.zero)
            // );
            // for (let r = 0; r < nRoundsF/2-1; r++) {
            //     state = state.map(a => pow5(a));
            //     state = state.map((a, i) => F.add(a, C[ (nRoundsF/2 +1)*t + nRoundsP + r*t + i ]));
            //     state = state.map((_, i) =>
            //         state.reduce((acc, a, j) => F.add(acc, F.mul(M[j][i], a)), F.zero)
            //     );
            // }
            // state = state.map(a => pow5(a));
            // state = state.map((_, i) =>
            //     state.reduce((acc, a, j) => F.add(acc, F.mul(M[j][i], a)), F.zero)
            // );
            // if (nOut == 1) {
            //     return state[0]
            // } else {
            //     return state.slice(0, nOut);
            // }
            // console.log(state)
            return F.toString(state[0]);
        }
        var bn128, F, opt, N_ROUNDS_F, ROUNDS_P, pow5;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, getCurveFromName("bn128", true)];
                case 1:
                    bn128 = _a.sent();
                    F = bn128.Fr;
                    opt = unsringifyConstants(F, poseidon_constants_opt_1.default);
                    N_ROUNDS_F = 8;
                    ROUNDS_P = [56, 57, 56, 60, 60, 63, 64, 63,] // 60, 66, 60, 65, 70, 60, 64, 68];
                    ;
                    pow5 = function (a) { return F.mul(a, F.square(F.square(a, a))); };
                    poseidon.F = F;
                    return [2 /*return*/, poseidon];
            }
        });
    });
}
exports.default = buildPoseidon;
