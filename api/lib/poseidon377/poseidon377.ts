// Parameters are generated by a reference script https://extgit.iaik.tugraz.at/krypto/hadeshash/-/blob/master/code/generate_parameters_grain.sage
// Used like so: sage generate_parameters_grain.sage 1 0 254 2 8 56 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001

// Using recommended parameters from whitepaper https://eprint.iacr.org/2019/458.pdf (table 2, table 8)
// Generated by https://extgit.iaik.tugraz.at/krypto/hadeshash/-/blob/master/code/calc_round_numbers.py
// And rounded up to nearest integer that divides by t

// Optimization is taken from https://github.com/filecoin-project/neptune

import assert from "assert";
// import { getCurveFromName }  from "@krigga/ffjavascript";
const {getCurveFromName} = require("@krigga/ffjavascript")

// import poseidonConstants from "./poseidon_constants_opt";
import poseidonConstants from "./constants"
// import {BLS, F as Field, F2, G1, G2, Defs} from "../bls12377js"
import { Fr as Field} from "../bls12377js"
// import {BLS, F as Field, F2, G1, G2, Defs} from "../bls12377js"
import { ethers } from "ethers";

function unsringifyConstants(o: any): any {
    if ((typeof(o) == "string") && (/^[0-9]+$/.test(o) ))  {
        return Field.fromString(o);
        // return Fr.e(o);
    } else if ((typeof(o) == "string") && (/^0x[0-9a-fA-F]+$/.test(o) ))  {
        return Field.fromString(o);
    } else if (Array.isArray(o)) {
        return o.map(o => unsringifyConstants(o));
    } else if (typeof o == "object") {
        const res: any = {};
        const keys = Object.keys(o);
        keys.forEach( (k) => {
            res[k] = unsringifyConstants(o[k]);
        });
        return res;
    } else {
        return o;
    }
}

export default async function buildPoseidon() {
    const N_ROUNDS_F = 8;
    const ROUNDS_P = 31;
    const pow5 = (a: Field) => {
        let res = a.multiply(a)     // a**2
        res = res.multiply(res)     // a**4
        return a.multiply(res)
    }
    const opt = unsringifyConstants(poseidonConstants);

    function poseidon(inputs: Array<string>, initState: any, nOut: any) {
        assert(inputs !== null)
        assert(inputs.map !== null)
        assert(inputs.length > 0);
        assert(inputs.length <= 6);

        // function arrToNumStr(fArr: Uint8Array[]): string[]{
        //     let ret: string[] = []
        //     fArr.forEach( e => {
        //         ret.push(F.toString(e))
        //     })
        //     return ret
        // }

        // if (initState) {
        //     initState = F.e(initState);
        // } else {
        //     initState = F.zero;
        // }
        nOut = nOut || 1;


        const t = inputs.length + 1;
        const nRoundsF = N_ROUNDS_F;

        const nRoundsP = ROUNDS_P;
        const C = opt.C[t-2];
        // const S = opt.S[t-2];
        const M = opt.M[t-2];
        // const P = opt.P[t-2];
        if(inputs === null || inputs.length === 0) return null
        let insfd = inputs.map((a: string) => Field.fromString(a))
        // let state = [initState, ...insfd];
        let state = [Field.zero(), ...insfd];

        // console.log("Printing inside poseidon_opt.ts")

        // console.log(`initial state: ${arrToNumStr(state)}`)

        // const f = 8;
        const p = nRoundsP
        for(let r=0; r<N_ROUNDS_F+p; r++){
        // for(let r=0; r<2; r++){
            // console.log(`outer loop r: ${r}`)
            //ark
            for(let i=0; i<t; i++){ 
                state[i] = state[i].add(C[r*t + i])
            }
            // console.log(`state after ark ${arrToNumStr(state)}`)

            //sbox
            state[0] = pow5(state[0])
            for(let i=1; i<t; i++){
                state[i] = ((r < N_ROUNDS_F/2) || r >= (N_ROUNDS_F/2 + p)) ? pow5(state[i]): state[i]
            }
            // console.log(`state after sbox ${arrToNumStr(state)}`)

            //mix
            let out = []
            for(let i=0; i<t; i++){
                let acc = Field.zero()
                for(let j=0; j<t; j++){
                    acc = acc.add(M[i][j].multiply(state[j]))
                }
                out.push(acc)
            }
            state = out
            // console.log(`state after mix ${arrToNumStr(state)}`)
        }
        
        // state = state.map((a, i) => F.add(a, C[i]));
        
        // //ark

        // //sbox
        // for (let r = 0; r < nRoundsP; r++) {
        //     state[0] = pow5(state[0]);
        //     state[0] = F.add(state[0], C[(nRoundsF/2 +1)*t + r]);


        //     const s0 = state.reduce((acc, a, j) => {
        //         return F.add(acc, F.mul(S[(t*2-1)*r+j], a));
        //     }, F.zero);
        //     for (let k=1; k<t; k++) {
        //         state[k] = F.add(state[k], F.mul(state[0], S[(t*2-1)*r+t+k-1]   ));
        //     }
        //     state[0] =s0;
        // }


        // for (let r = 0; r < nRoundsF/2-1; r++) {
        //     state = state.map(a => pow5(a));
        //     state = state.map((a, i) => F.add(a, C[(r +1)* t +i]));
        //     state = state.map((_, i) =>
        //         state.reduce((acc, a, j) => F.add(acc, F.mul(M[j][i], a)), F.zero)
        //     );
        // }
        // state = state.map(a => pow5(a));
        // state = state.map((a, i) => F.add(a, C[(nRoundsF/2-1 +1)* t +i]));
        // state = state.map((_, i) =>
        //     state.reduce((acc, a, j) => F.add(acc, F.mul(P[j][i], a)), F.zero)
        // );


        // for (let r = 0; r < nRoundsF/2-1; r++) {
        //     state = state.map(a => pow5(a));
        //     state = state.map((a, i) => F.add(a, C[ (nRoundsF/2 +1)*t + nRoundsP + r*t + i ]));
        //     state = state.map((_, i) =>
        //         state.reduce((acc, a, j) => F.add(acc, F.mul(M[j][i], a)), F.zero)
        //     );
        // }
        // state = state.map(a => pow5(a));
        // state = state.map((_, i) =>
        //     state.reduce((acc, a, j) => F.add(acc, F.mul(M[j][i], a)), F.zero)
        // );

        // if (nOut == 1) {
        //     return state[0]
        // } else {
        //     return state.slice(0, nOut);
        // }
        // console.log(state)
        return state[0].toString()
    }
    // poseidon.F = F;
    return poseidon;
}


