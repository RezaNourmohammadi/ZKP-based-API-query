import "hashes/poseidon/poseidon" as poseidon;
from "../common.zok" import performConditionCheck, hashDataPoint, merkleize4;
/*
 Takes 4 rows as inputs, along with a set of 5 conditions (coded in 3 5-len arrays).
 Returns the count of the number of rows satisfying the AND-aggregate of the conditions
*/
def main(private field[4][8] row, field[5] cmpVal, u32[5] queryFieldIndex, u32[5] queryOp) -> (u32, field) {
    u32 mut count = 0;
    for u32 i in 0..4{
        bool mut compoundConditional = true;
            for u32 j in 0..5 {
                compoundConditional = compoundConditional &&  (
                    if queryOp[j] == 0 {true} 
                    else {
                        performConditionCheck(row[i][queryFieldIndex[j]], cmpVal[j], queryOp[j])
                    }
                );
            }
        count = count + (if compoundConditional {1} else {0});
    }
    field merkle4 = merkleize4(row);
    // assert(root7Level == merkle4);
    return (count, merkle4);
}


/* 
// To run
zokrates compile --debug -i firstLevel4Rows5Conds.zok
zokrates compute-witness --verbose -a \
1 99 2 99 3 99 4 99 \
1 99 2 99 3 99 4 99 \
1 99 2 99 3 99 4 99 \
1 99 2 99 3 99 4 99 \
1 2 3 4 5 \
0 2 4 6 7 \
1 1 1 1 0
zokrates setup
zokrates generate-proof
zokrates verify

*/

// THIS PASSES
/*
The witness should return the count, according to how many rows pass the condition set,
something like 
Witness: 
["4","18318441551264111191536232566685743521022194936934702641664220904641842846225"]
for 
1 2 3 4 5 \
0 2 4 6 7 \
1 1 1 1 0

which means, (==) checks for fields at indices 0 2 4 6, with values 1 2 3 4; and no comparison for the fifth one (ignore)
*/